/**
 * fabs/js/cojoin.js
 *
 * This script contains the logic for both the Contact Us and Join Us forms.
 * It handles form submission, security checks (honeypot, malicious code),
 * and the dynamic form fields for the Join form.
 */

function initCojoinForms() {

  const contactForm = document.getElementById('contactForm');
  const joinForm = document.getElementById('joinForm');

  function showFormError(form, message) {
    const region = form.querySelector('.form-errors');
    if (region) {
      region.textContent = message;
    }
  }

  function clearFormError(form) {
    const region = form.querySelector('.form-errors');
    if (region) {
      region.textContent = '';
    }
  }

  if (contactForm && !contactForm.dataset.cojoinInitialized) {
    contactForm.addEventListener('submit', handleContactSubmit);
    contactForm.dataset.cojoinInitialized = 'true';
  }

  if (joinForm && !joinForm.dataset.cojoinInitialized) {
    joinForm.addEventListener('submit', handleJoinSubmit);
    joinForm.dataset.cojoinInitialized = 'true';
    initJoinForm();
  }

  /**
   * Sanitizes input to prevent malicious code injection.
   * This is a simple client-side check and not a replacement for server-side validation.
   * @param {string} input The string to sanitize.
   * @returns {string} The sanitized string.
   */
    function sanitizeInput(input) {
      // Regex to find common malicious patterns
      const maliciousPatterns = /<script.*?>.*?<\/script>|javascript:|on\w+=|onerror=|onload=|<\w+[^>]*\s+[^>]*on\w+=/ig;
      const cleaned = input.replace(maliciousPatterns, '');

      if (typeof document !== 'undefined') {
        const div = document.createElement('div');
        if (typeof div.innerHTML === 'string') {
          div.innerHTML = cleaned;
          return div.textContent || '';
        }
        div.textContent = cleaned;
        return div.textContent.replace(/<[^>]*>/g, '');
      }
      return cleaned.replace(/<[^>]*>/g, '');
    }

  /**
   * Retrieves an AES-GCM key generated by a server-side KMS/HSM.
   * The server is responsible for managing the lifecycle of this key
   * in alignment with NIST and PCI DSS requirements.
   * @returns {Promise<CryptoKey>} The imported AES-GCM key.
   */
  async function getAesKeyFromKms() {
    const res = await fetch('https://your-server.example.com/kms/aes-key');
    const { key } = await res.json(); // base64 encoded key material
    const rawKey = base64ToArrayBuffer(key);
    return crypto.subtle.importKey('raw', rawKey, { name: 'AES-GCM' }, false, ['encrypt']);
  }

  /**
   * Requests a short-lived bearer token from the server. The token is
   * returned as an AES-GCM encrypted blob alongside its IV so it can be
   * decrypted by the Cloudflare worker.
   * @returns {Promise<{token: string, iv: string}>}
   */
  async function getBearerToken() {
    const res = await fetch('https://your-server.example.com/auth/token');
    return res.json(); // { token: base64CipherText, iv: base64IV }
  }

  function arrayBufferToBase64(buffer) {
    return btoa(String.fromCharCode(...new Uint8Array(buffer)));
  }

  function base64ToArrayBuffer(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer;
  }

  /**
   * Simulated function to send data to a Cloudflare worker.
   * This is where you would implement your data encryption logic before sending.
   * @param {object} data The sanitized form data to send.
   */
  async function sendToCloudflareWorker(data) {
    console.log("Data is clean. Encrypting and sending to Cloudflare worker...", data);
    try {
      // Retrieve managed key and short-lived token from the server
      const [aesKey, tokenInfo] = await Promise.all([
        getAesKeyFromKms(),
        getBearerToken(),
      ]);

      // Encrypt payload using AES-GCM
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encoder = new TextEncoder();
      const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv },
        aesKey,
        encoder.encode(JSON.stringify(data))
      );

      const payload = {
        iv: Array.from(iv),
        payload: arrayBufferToBase64(encrypted),
      };

      // Compose Authorization header as Bearer <iv>.<cipher>
      const authHeader = `Bearer ${tokenInfo.iv}.${tokenInfo.token}`;

      const response = await fetch('https://your-cloudflare-worker.example.com/api', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': authHeader,
        },
        body: JSON.stringify(payload),
      });

      if (response.ok) {
        console.log('Data successfully sent and processed by Cloudflare worker.');
      } else {
        console.error('Failed to send data to Cloudflare worker.');
      }
    } catch (error) {
      console.error('Network error or worker unreachable:', error);
    }
  }

  /**
   * Contact Us form submission handler.
   * @param {Event} e The form submission event.
   */
  async function handleContactSubmit(e) {
    e.preventDefault();

    const form = e.target;
    clearFormError(form);

    if (!form.checkValidity()) {
      showFormError(form, 'Please fill out all required fields.');
      if (form.reportValidity) {
        form.reportValidity();
      }
      return;
    }

    // 1. Honeypot check: Block if this hidden field is filled
    const honeypotField = document.getElementById('honeypot-contact');
    if (honeypotField && honeypotField.value !== '') {
      console.warn('Honeypot filled. Blocking form submission.');
      showFormError(form, 'Invalid submission.');
      form.reset(); // Reset form to clear any malicious data
      return;
    }

    const formData = new FormData(form);
    const data = Object.fromEntries(formData.entries());

    // 2. Malicious code check and sanitization
    const sanitizedData = {};
    for (const key in data) {
      const sanitizedValue = sanitizeInput(data[key]);
      sanitizedData[key] = sanitizedValue;
    }
    
    // 3. Prepare and send sanitized data to worker
    alert('Contact form submitted successfully!');
    await sendToCloudflareWorker(sanitizedData);
    form.reset();
    clearFormError(form);
    if (window.hideActiveFabModal) {
      window.hideActiveFabModal();
    }
  }

  /**
   * Join Us form submission handler.
   * @param {Event} e The form submission event.
   */
  async function handleJoinSubmit(e) {
    e.preventDefault();

    const form = e.target;
    clearFormError(form);

    if (!form.checkValidity()) {
      showFormError(form, 'Please fill out all required fields.');
      if (form.reportValidity) {
        form.reportValidity();
      }
      return;
    }

    // 1. Honeypot check
    const honeypotField = document.getElementById('honeypot-join');
    if (honeypotField && honeypotField.value !== '') {
      console.warn('Honeypot filled. Blocking form submission.');
      showFormError(form, 'Invalid submission.');
      form.reset();
      return;
    }

    const formData = new FormData(form);
    const data = Object.fromEntries(formData.entries());

    // Check that all dynamic sections are 'accepted' or empty
    const formSections = document.querySelectorAll('.form-section[data-section]');
    for (const section of formSections) {
      const inputs = section.querySelectorAll('input[type=text]');
      if (inputs.length > 0 && !section.classList.contains('completed')) {
        showFormError(form, `Please accept your entries in "${section.querySelector('h2').textContent}" or remove them.`);
        return;
      }
    }

    // 2. Malicious code check and sanitization
    const sanitizedData = {};
    for (const key in data) {
      const sanitizedValue = sanitizeInput(data[key]);
      sanitizedData[key] = sanitizedValue;
    }

    // 3. Prepare and send sanitized data to worker
    alert('Join form submitted successfully!');
    await sendToCloudflareWorker(sanitizedData);
    form.reset();
    clearFormError(form);
    resetJoinFormState();
    if (window.hideActiveFabModal) {
      window.hideActiveFabModal();
    }
  }

  /**
   * Initializes event listeners for the Join Us form's dynamic sections.
   */
  function initJoinForm() {
    const formSections = document.querySelectorAll('.form-section[data-section]');
    formSections.forEach(section => {
      const addBtn = section.querySelector('.circle-btn.add');
      const removeBtn = section.querySelector('.circle-btn.remove');
      const acceptBtn = section.querySelector('.accept-btn');
      const editBtn = section.querySelector('.edit-btn');
      const inputsContainer = section.querySelector('.inputs');

      if (addBtn) {
        addBtn.addEventListener('click', () => {
          let field;
          if (section.dataset.section === 'Experience') {
            const count = inputsContainer.querySelectorAll('textarea').length + 1;
            field = document.createElement('textarea');
            field.rows = 3;
            field.placeholder = `tell us about your Experience ${count}`;
          } else if (section.dataset.section === 'Continued Education') {
            field = document.createElement('textarea');
            field.rows = 3;
            field.placeholder = 'Online Courses, Seminars, Webinars with Completion Certification';
          } else {
            field = document.createElement('input');
            field.type = 'text';
            field.placeholder = `Enter ${section.querySelector('h2').textContent.toLowerCase()}`;
          }
          inputsContainer.appendChild(field);
          field.focus();
        });
      }

      if (removeBtn) {
        removeBtn.addEventListener('click', () => {
          if (!section.classList.contains('completed')) {
            if (inputsContainer.lastElementChild) {
              inputsContainer.removeChild(inputsContainer.lastElementChild);
            }
          }
        });
      }

      if (acceptBtn) {
        acceptBtn.addEventListener('click', () => {
          const inputs = inputsContainer.querySelectorAll('input[type=text], textarea');
          if (inputs.length === 0) {
            showFormError(joinForm, 'Add at least one entry.');
            return;
          }
          for (const input of inputs) {
            if (!input.value.trim()) {
              showFormError(joinForm, 'Please fill out all fields before accepting.');
              return;
            }
          }
          clearFormError(joinForm);
          toggleSectionState(section, true);
        });
      }

      if (editBtn) {
        editBtn.addEventListener('click', () => {
          toggleSectionState(section, false);
        });
      }
    });
  }

  /**
   * Resets the Join Us form to its initial state after submission.
   */
  function resetJoinFormState() {
    const formSections = document.querySelectorAll('.form-section[data-section]');
    formSections.forEach(section => {
      toggleSectionState(section, false);
      const inputsContainer = section.querySelector('.inputs');
      inputsContainer.innerHTML = '';
    });
  }

  /**
   * Toggles the state of a dynamic form section (accepted/editable).
   * @param {HTMLElement} section The form section element.
   * @param {boolean} accepted True to lock the section, false to unlock.
   */
  function toggleSectionState(section, accepted) {
    const inputs = section.querySelectorAll('input[type=text], textarea');
    const acceptBtn = section.querySelector('.accept-btn');
    const editBtn = section.querySelector('.edit-btn');
    const addBtn = section.querySelector('.circle-btn.add');
    const removeBtn = section.querySelector('.circle-btn.remove');

    inputs.forEach(input => input.disabled = accepted);

    if (accepted) {
      if (acceptBtn) acceptBtn.classList.add('hidden');
      if (editBtn) editBtn.classList.remove('hidden');
      if (addBtn) addBtn.disabled = true;
      if (removeBtn) removeBtn.disabled = true;
      section.classList.add('completed');
    } else {
      if (acceptBtn) acceptBtn.classList.remove('hidden');
      if (editBtn) editBtn.classList.add('hidden');
      if (addBtn) addBtn.disabled = false;
      if (removeBtn) removeBtn.disabled = false;
      section.classList.remove('completed');
    }
  }
}

// Reference the shared draggable helper if available
if (typeof window.makeDraggable === 'function') {
  window.initDraggableModal = window.makeDraggable;
}

window.initCojoinForms = initCojoinForms;
document.addEventListener('DOMContentLoaded', initCojoinForms);
